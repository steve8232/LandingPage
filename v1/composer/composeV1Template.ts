/**
 * v1 Template Composer
 *
 * composeV1Template(templateId) is the single entry point that turns a
 * declarative TemplateSpec into a self-contained HTML string.
 *
 * Pipeline:
 *   1. Load spec from the spec registry
 *   2. Validate it
 *   3. Read tokens.css + theme CSS (inlined)
 *   4. Render form fields from spec.form
 *   5. Loop through spec.sections → call sectionRegistry[type](props)
 *   6. Wrap everything in a full HTML document with <div class="v1-page">
 *
 * Architecture decision: CSS is inlined via <style> tags so the output is
 * fully self-contained — no external file dependencies. This makes preview
 * generation and thumbnail screenshots trivial.
 */

import { getV1Spec } from '../specs/index';
import { validateSpec, TemplateSpec, V1FormField } from '../specs/schema';
import { sectionRegistry } from '../sections/index';
import { resolveAsset, getDemoAttributions, DemoAssetEntry, ResolvedAsset } from '../assets/resolveAsset';

// ── CSS loading ────────────────────────────────────────────────────────────────

/**
 * In a Node / build-script context we read CSS from disk.
 * In a Next.js server-component context we also have access to `fs`.
 * We lazy-import fs so this module can be safely imported in environments
 * where fs is available (server) without crashing in the browser.
 */
let _readFileSync: ((path: string, enc: string) => string) | null = null;

function readCssFile(relativePath: string): string {
  try {
    if (!_readFileSync) {
      // eslint-disable-next-line @typescript-eslint/no-require-imports
      _readFileSync = require('fs').readFileSync;
    }
    const path = require('path');
    const filePath = path.resolve(process.cwd(), relativePath);
    return _readFileSync!(filePath, 'utf-8');
  } catch {
    // Fallback: return empty string (e.g. when running in browser context)
    console.warn(`[v1 composer] Could not read CSS file: ${relativePath}`);
    return '';
  }
}

function loadTokensCss(): string {
  return readCssFile('v1/themes/tokens.css');
}

function loadThemeCss(themeName: string): string {
  return readCssFile(`v1/themes/${themeName}.css`);
}

// ── Form rendering ─────────────────────────────────────────────────────────────

function renderFormFields(
  fields: V1FormField[],
  formOverrides?: Record<string, { placeholder?: string; label?: string }>
): string {
  return fields
    .map((f) => {
      const req = f.required ? 'required' : '';
      const overridePh = formOverrides?.[f.name]?.placeholder;
      const placeholder = overridePh || f.placeholder;
      const ph = placeholder ? `placeholder="${escapeAttr(placeholder)}"` : '';
      const overrideLabel = formOverrides?.[f.name]?.label;
      const style = `
        width: 100%; padding: 12px; margin-bottom: 12px;
        border: 1px solid rgba(255,255,255,0.3);
        border-radius: var(--v1-radius-md);
        font-size: var(--v1-font-size-base);
        background: rgba(255,255,255,0.1);
        color: var(--v1-color-cta-text);
      `;
      const labelStyle = `
        display: block; margin-bottom: 4px;
        font-size: var(--v1-font-size-sm);
        font-weight: var(--v1-font-weight-medium);
        color: var(--v1-color-cta-text);
        opacity: 0.85;
      `;
      const labelHtml = overrideLabel
        ? `<label for="v1-${escapeAttr(f.name)}" style="${labelStyle}">${escapeHtml(overrideLabel)}</label>`
        : '';

      if (f.type === 'textarea') {
        return `${labelHtml}<textarea id="v1-${escapeAttr(f.name)}" name="${escapeAttr(f.name)}" ${ph} rows="4" ${req} style="${style}"></textarea>`;
      }
      return `${labelHtml}<input id="v1-${escapeAttr(f.name)}" type="${f.type}" name="${escapeAttr(f.name)}" ${ph} ${req} style="${style}" />`;
    })
    .join('\n');
}

// ── Main composer ──────────────────────────────────────────────────────────────

export interface ComposeResult {
  html: string;
  templateId: string;
}

/**
 * Content overrides — generated by the AI content module and merged into
 * the spec's section props before rendering.
 *
 * `sections` is an array parallel to spec.sections: each element is a
 * partial prop object that gets shallow-merged on top of the spec defaults.
 * `null` entries mean "keep the original spec props unchanged".
 *
 * `assets` maps spec asset keys to user-provided URLs (e.g. base64 data URIs
 * from uploaded images) which override the demo/placeholder URLs.
 */
/**
 * SEO and branding metadata produced by the enhancement pass.
 */
export interface V1MetaOverrides {
  pageTitle?: string;
  metaDescription?: string;
  tagline?: string;
  imageAltTexts?: Record<string, string>;
}

export interface V1ContentOverrides {
  sections?: (Record<string, unknown> | null)[];
  assets?: Record<string, string>;
  /** SEO / branding metadata from the enhancement pass */
  meta?: V1MetaOverrides;
  /** Personalized form-field placeholders keyed by field name */
  formOverrides?: Record<string, { placeholder?: string; label?: string }>;
  /** AI-generated stock photo search terms keyed by section role */
  imageSearchTerms?: Record<string, string>;
}

export function composeV1Template(
  templateId: string,
  overrides?: V1ContentOverrides
): ComposeResult {
  // 1. Load spec
  const spec = getV1Spec(templateId);
  if (!spec) {
    throw new Error(`[v1 composer] No spec found for templateId: ${templateId}`);
  }

  // 2. Validate
  const validation = validateSpec(spec);
  if (!validation.valid) {
    throw new Error(
      `[v1 composer] Invalid spec "${templateId}":\n  ${validation.errors.join('\n  ')}`
    );
  }

  // 3. Load CSS
  const tokensCss = loadTokensCss();
  const themeCss = loadThemeCss(spec.theme);

  // 4. Pre-render form HTML for injection into FinalCTA
  const formHtml = renderFormFields(spec.form, overrides?.formOverrides);

  // 4b. Resolve all demo asset IDs → real URLs (with fallback)
  // User-provided asset overrides take priority over spec defaults
  const mergedAssets = { ...spec.assets, ...(overrides?.assets ?? {}) };
  const resolvedAssets: Record<string, string> = {};
  for (const [key, value] of Object.entries(mergedAssets)) {
    // User-provided data URIs or absolute URLs don't need demo resolution
    if (value.startsWith('data:') || value.startsWith('http://') || value.startsWith('https://')) {
      resolvedAssets[key] = value;
    } else {
      const fallback = getFallbackForAssetKey(key, mergedAssets);
      resolvedAssets[key] = value.startsWith('demo-')
        ? resolveAsset(value, fallback).src
        : resolveAsset(value).src;
    }
  }

  // Track which demo IDs are actually used by rendered sections
  const usedDemoIds = new Set<string>();

  // 5. Render each section
  const sectionsHtml = spec.sections
    .map((entry, sectionIndex) => {
      const renderer = sectionRegistry[entry.type];
      if (!renderer) {
        console.warn(`[v1 composer] Unknown section type: ${entry.type}`);
        return `<!-- unknown section: ${entry.type} -->`;
      }

      // Prepare props — merge spec defaults with content overrides
      const sectionOverride = overrides?.sections?.[sectionIndex];
      const props = sectionOverride
        ? { ...entry.props, ...sectionOverride }
        : { ...entry.props };

      // Resolve image asset references in props (using resolved URLs)
      // HeroSplit
      if (typeof props.imageAsset === 'string' && resolvedAssets[props.imageAsset as string]) {
        const assetKey = props.imageAsset as string;
        props._resolvedImageUrl = resolvedAssets[assetKey];
        const id = spec.assets[assetKey];
        if (typeof id === 'string' && id.startsWith('demo-')) usedDemoIds.add(id);
      }
      if (typeof (props as Record<string, unknown>).fallbackAsset === 'string') {
        const fbKey = (props as Record<string, unknown>).fallbackAsset as string;
        if (resolvedAssets[fbKey]) props._fallbackImageUrl = resolvedAssets[fbKey];
      }

      // ImagePair
      if (typeof (props as Record<string, unknown>).imageAsset1 === 'string') {
        const k = (props as Record<string, unknown>).imageAsset1 as string;
        if (resolvedAssets[k]) {
          (props as Record<string, unknown>)._resolvedImageUrl1 = resolvedAssets[k];
          const id = spec.assets[k];
          if (typeof id === 'string' && id.startsWith('demo-')) usedDemoIds.add(id);
        }
      }
      if (typeof (props as Record<string, unknown>).fallbackAsset1 === 'string') {
        const k = (props as Record<string, unknown>).fallbackAsset1 as string;
        if (resolvedAssets[k]) (props as Record<string, unknown>)._fallbackImageUrl1 = resolvedAssets[k];
      }
      if (typeof (props as Record<string, unknown>).imageAsset2 === 'string') {
        const k = (props as Record<string, unknown>).imageAsset2 as string;
        if (resolvedAssets[k]) {
          (props as Record<string, unknown>)._resolvedImageUrl2 = resolvedAssets[k];
          const id = spec.assets[k];
          if (typeof id === 'string' && id.startsWith('demo-')) usedDemoIds.add(id);
        }
      }
      if (typeof (props as Record<string, unknown>).fallbackAsset2 === 'string') {
        const k = (props as Record<string, unknown>).fallbackAsset2 as string;
        if (resolvedAssets[k]) (props as Record<string, unknown>)._fallbackImageUrl2 = resolvedAssets[k];
      }

      // Inject alt text from enhancement overrides
      const altTexts = overrides?.meta?.imageAltTexts;
      if (altTexts) {
        // HeroSplit: imageAsset → _altText
        if (typeof props.imageAsset === 'string' && altTexts[props.imageAsset as string]) {
          props._altText = altTexts[props.imageAsset as string];
        }
        // ImagePair: imageAsset1 → _altText1, imageAsset2 → _altText2
        const p = props as Record<string, unknown>;
        if (typeof p.imageAsset1 === 'string' && altTexts[p.imageAsset1 as string]) {
          p._altText1 = altTexts[p.imageAsset1 as string];
        }
        if (typeof p.imageAsset2 === 'string' && altTexts[p.imageAsset2 as string]) {
          p._altText2 = altTexts[p.imageAsset2 as string];
        }
      }

      // Inject AI-generated image search terms as fallback alt texts
      const imgTerms = overrides?.imageSearchTerms;
      if (imgTerms) {
        const p = props as Record<string, unknown>;
        if (entry.type === 'HeroSplit' && imgTerms.hero && !props._altText) {
          props._altText = imgTerms.hero;
        }
        if (entry.type === 'ImagePair') {
          if (imgTerms.image1 && !p._altText1) p._altText1 = imgTerms.image1;
          if (imgTerms.image2 && !p._altText2) p._altText2 = imgTerms.image2;
        }
      }

      // Inject form HTML into FinalCTA sections
      if (entry.type === 'FinalCTA') {
        props._formHtml = formHtml;
      }

      return renderer(props);
    })
    .join('\n');

  // 5b. Build attribution footer from demo assets
  const attributions = getDemoAttributions(Array.from(usedDemoIds));
  const attrHtml = renderAttributionFooter(attributions);

  // 6. Wrap in full HTML document
  const html = buildDocument(spec, tokensCss, themeCss, sectionsHtml, attrHtml, overrides?.meta);

  return { html, templateId };
}

function getFallbackForAssetKey(key: string, assets: Record<string, string>): string | undefined {
  if (key.startsWith('fallback')) return undefined;

  const cap = key.length > 0 ? key[0].toUpperCase() + key.slice(1) : key;
  const candidates = [`fallback${cap}`, `fallback-${key}`];
  for (const c of candidates) {
    if (c in assets && typeof assets[c] === 'string') return assets[c];
  }
  return undefined;
}

// ── Document wrapper ───────────────────────────────────────────────────────────

function buildDocument(
  spec: TemplateSpec,
  tokensCss: string,
  themeCss: string,
  sectionsHtml: string,
  attributionHtml: string,
  meta?: V1MetaOverrides
): string {
  const pageTitle = meta?.pageTitle || spec.metadata.name;
  const metaDesc = meta?.metaDescription || spec.metadata.description;
  const taglineTag = meta?.tagline
    ? `\n  <meta name="v1-tagline" content="${escapeAttr(meta.tagline)}">`
    : '';

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="${escapeAttr(metaDesc)}">${taglineTag}
  <title>${escapeHtml(pageTitle)}</title>
  <style>
/* === v1 tokens === */
${tokensCss}
/* === v1 theme: ${spec.theme} === */
${themeCss}
  </style>
</head>
<body>
  <div class="v1-page">
${sectionsHtml}
${attributionHtml}
  </div>
</body>
</html>`;
}

// ── Attribution footer ──────────────────────────────────────────────────────

function renderAttributionFooter(attributions: DemoAssetEntry[]): string {
  if (attributions.length === 0) return '';

  const credits = attributions
    .map(
      (a) =>
        `<a href="${escapeAttr(a.source_page_url)}" target="_blank" rel="noopener noreferrer" style="color: inherit; text-decoration: underline;">${escapeHtml(a.attribution_text)}</a>`
    )
    .join(' · ');

  return `
<footer class="v1-attribution" style="
  padding: 12px 24px;
  background: #f5f5f5;
  color: #666;
  font-size: 11px;
  text-align: center;
  border-top: 1px solid #e0e0e0;
">
  Demo images: ${credits}
</footer>`;
}

// ── Helpers ────────────────────────────────────────────────────────────────────

function escapeHtml(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

function escapeAttr(str: string): string {
  return str.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

