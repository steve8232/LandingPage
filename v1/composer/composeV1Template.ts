/**
 * v1 Template Composer
 *
 * composeV1Template(templateId) is the single entry point that turns a
 * declarative TemplateSpec into a self-contained HTML string.
 *
 * Pipeline:
 *   1. Load spec from the spec registry
 *   2. Validate it
 *   3. Read tokens.css + theme CSS (inlined)
 *   4. Render form fields from spec.form
 *   5. Loop through spec.sections → call sectionRegistry[type](props)
 *   6. Wrap everything in a full HTML document with <div class="v1-page">
 *
 * Architecture decision: CSS is inlined via <style> tags so the output is
 * fully self-contained — no external file dependencies. This makes preview
 * generation and thumbnail screenshots trivial.
 */

import { getV1Spec } from '../specs/index';
import { validateSpec, TemplateSpec, V1FormField } from '../specs/schema';
import { sectionRegistry } from '../sections/index';
import { resolveAsset, getDemoAttributions, DemoAssetEntry, ResolvedAsset } from '../assets/resolveAsset';

// ── Asset inlining (SVG placeholders) ─────────────────────────────────────────

/**
 * v1 outputs are intended to be *single-file* HTML. Specs reference SVG
 * placeholders via /v1/assets/... paths, but those paths won't exist when
 * the HTML is opened as a standalone file.
 *
 * To preserve the architecture while meeting the self-contained constraint,
 * we inline local SVG placeholder files as data: URIs at compose-time.
 */
const _svgDataUriCache = new Map<string, string>();

function inlineLocalSvgIfPossible(src: string): string {
  // Only inline local v1 SVGs (placeholders/logo/avatar). Remote demo images stay remote.
  if (!src.startsWith('/v1/assets/') || !src.toLowerCase().endsWith('.svg')) return src;
  if (src.startsWith('data:')) return src;

  const cached = _svgDataUriCache.get(src);
  if (cached) return cached;

  try {
    if (!_readFileSync) {
      // eslint-disable-next-line @typescript-eslint/no-require-imports
      _readFileSync = require('fs').readFileSync;
    }
    const path = require('path');
    const relativePath = src.replace(/^\//, ''); // "/v1/assets/..." → "v1/assets/..."
    const filePath = path.resolve(process.cwd(), relativePath);
    const svg = _readFileSync!(filePath, 'utf-8');
    const b64 = Buffer.from(svg, 'utf-8').toString('base64');
    const dataUri = `data:image/svg+xml;base64,${b64}`;
    _svgDataUriCache.set(src, dataUri);
    return dataUri;
  } catch {
    // If we can't read it (e.g. browser context), fall back to original.
    return src;
  }
}

// ── CSS loading ────────────────────────────────────────────────────────────────

/**
 * In a Node / build-script context we read CSS from disk.
 * In a Next.js server-component context we also have access to `fs`.
 * We lazy-import fs so this module can be safely imported in environments
 * where fs is available (server) without crashing in the browser.
 */
let _readFileSync: ((path: string, enc: string) => string) | null = null;

function readCssFile(relativePath: string): string {
  try {
    if (!_readFileSync) {
      // eslint-disable-next-line @typescript-eslint/no-require-imports
      _readFileSync = require('fs').readFileSync;
    }
    const path = require('path');
    const filePath = path.resolve(process.cwd(), relativePath);
    return _readFileSync!(filePath, 'utf-8');
  } catch {
    // Fallback: return empty string (e.g. when running in browser context)
    console.warn(`[v1 composer] Could not read CSS file: ${relativePath}`);
    return '';
  }
}

function loadTokensCss(): string {
  return readCssFile('v1/themes/tokens.css');
}

function loadThemeCss(themeName: string): string {
  return readCssFile(`v1/themes/${themeName}.css`);
}

// ── Form rendering ─────────────────────────────────────────────────────────────

function renderFormFields(
  fields: V1FormField[],
  formOverrides?: Record<string, { placeholder?: string; label?: string }>
): string {
  return fields
    .map((f) => {
      const req = f.required ? 'required' : '';
      const overridePh = formOverrides?.[f.name]?.placeholder;
      const placeholder = overridePh || f.placeholder;
      const ph = placeholder ? `placeholder="${escapeAttr(placeholder)}"` : '';
      const overrideLabel = formOverrides?.[f.name]?.label;
      const labelHtml = overrideLabel
        ? `<label for="v1-${escapeAttr(f.name)}" class="v1-label">${escapeHtml(overrideLabel)}</label>`
        : '';

      const baseAttrs = `id="v1-${escapeAttr(f.name)}" name="${escapeAttr(f.name)}" ${ph} ${req} class="v1-input"`;

      if (f.type === 'textarea') {
        return `<div class="v1-field">${labelHtml}<textarea ${baseAttrs} rows="4"></textarea></div>`;
      }
      return `<div class="v1-field">${labelHtml}<input ${baseAttrs} type="${escapeAttr(f.type)}" /></div>`;
    })
    .join('\n');
}

// ── Main composer ──────────────────────────────────────────────────────────────

export interface ComposeResult {
  html: string;
  templateId: string;
}

/**
 * Content overrides — generated by the AI content module and merged into
 * the spec's section props before rendering.
 *
 * `sections` is an array parallel to spec.sections: each element is a
 * partial prop object that gets shallow-merged on top of the spec defaults.
 * `null` entries mean "keep the original spec props unchanged".
 *
 * `assets` maps spec asset keys to user-provided URLs (e.g. base64 data URIs
 * from uploaded images) which override the demo/placeholder URLs.
 */
/**
 * SEO and branding metadata produced by the enhancement pass.
 */
export interface V1MetaOverrides {
  pageTitle?: string;
  metaDescription?: string;
  tagline?: string;
  imageAltTexts?: Record<string, string>;
}

export interface V1ContentOverrides {
  sections?: (Record<string, unknown> | null)[];
  assets?: Record<string, string>;
  /** SEO / branding metadata from the enhancement pass */
  meta?: V1MetaOverrides;
  /** Personalized form-field placeholders keyed by field name */
  formOverrides?: Record<string, { placeholder?: string; label?: string }>;
  /** AI-generated stock photo search terms keyed by section role */
  imageSearchTerms?: Record<string, string>;
}

export interface ComposeV1Options {
  /**
   * If true, demo asset IDs (demo-*) resolve to remote image URLs.
   * If false (default), demo assets resolve to their local SVG fallbacks so
   * composed HTML contains no remote demo image URLs.
   */
  allowRemoteDemoImages?: boolean;
}

export function composeV1Template(
  templateId: string,
  overrides?: V1ContentOverrides,
  options?: ComposeV1Options
): ComposeResult {
  const allowRemoteDemoImages = options?.allowRemoteDemoImages === true;

  // 1. Load spec
  const spec = getV1Spec(templateId);
  if (!spec) {
    throw new Error(`[v1 composer] No spec found for templateId: ${templateId}`);
  }

  // 2. Validate
  const validation = validateSpec(spec);
  if (!validation.valid) {
    throw new Error(
      `[v1 composer] Invalid spec "${templateId}":\n  ${validation.errors.join('\n  ')}`
    );
  }

  // 3. Load CSS
  const tokensCss = loadTokensCss();
  const themeCss = loadThemeCss(spec.theme);

  // 4. Pre-render form HTML for injection into FinalCTA
  const formHtml = renderFormFields(spec.form, overrides?.formOverrides);

  // 4b. Resolve all asset IDs → final src strings (offline-safe by default)
  // User-provided asset overrides take priority over spec defaults
  const mergedAssets = { ...spec.assets, ...(overrides?.assets ?? {}) };
  const resolvedAssets: Record<string, string> = {};
  for (const [key, value] of Object.entries(mergedAssets)) {
    // User-provided data URIs or absolute URLs don't need demo resolution
    if (value.startsWith('data:') || value.startsWith('http://') || value.startsWith('https://')) {
      resolvedAssets[key] = value;
    } else {
      const fallback = getFallbackForAssetKey(key, mergedAssets);
      if (value.startsWith('demo-')) {
        // Default: keep v1 HTML self-contained by using local SVG fallbacks.
        // Opt-in: allow remote demo images for online previews.
        resolvedAssets[key] = allowRemoteDemoImages
          ? resolveAsset(value, fallback).src
          : fallback || '/v1/assets/placeholders/common/logo-placeholder.svg';
      } else {
        resolvedAssets[key] = resolveAsset(value).src;
      }
    }

    // Inline local SVG placeholders so the final HTML is truly single-file.
    resolvedAssets[key] = inlineLocalSvgIfPossible(resolvedAssets[key]);
  }

  // Track which demo IDs are actually used by rendered sections
  const usedDemoIds = new Set<string>();

  // 5. Render each section
  const sectionsHtml = spec.sections
    .map((entry, sectionIndex) => {
      const renderer = sectionRegistry[entry.type];
      if (!renderer) {
        console.warn(`[v1 composer] Unknown section type: ${entry.type}`);
        return `<!-- unknown section: ${entry.type} -->`;
      }

      // Prepare props — merge spec defaults with content overrides
      const sectionOverride = overrides?.sections?.[sectionIndex];
	    if (
	      sectionOverride &&
	      typeof sectionOverride === 'object' &&
	      (sectionOverride as Record<string, unknown>)._omit === true
	    ) {
	      return `<!-- omitted section: ${entry.type} -->`;
	    }
      const props = sectionOverride
        ? { ...entry.props, ...sectionOverride }
        : { ...entry.props };

      // Resolve image asset references in props (using resolved URLs)
      // HeroSplit
      if (typeof props.imageAsset === 'string' && resolvedAssets[props.imageAsset as string]) {
        const assetKey = props.imageAsset as string;
        props._resolvedImageUrl = resolvedAssets[assetKey];
        const id = spec.assets[assetKey];
        if (allowRemoteDemoImages && typeof id === 'string' && id.startsWith('demo-')) usedDemoIds.add(id);
      }
      if (typeof (props as Record<string, unknown>).fallbackAsset === 'string') {
        const fbKey = (props as Record<string, unknown>).fallbackAsset as string;
        if (resolvedAssets[fbKey]) props._fallbackImageUrl = resolvedAssets[fbKey];
      }

      // ImagePair
      if (typeof (props as Record<string, unknown>).imageAsset1 === 'string') {
        const k = (props as Record<string, unknown>).imageAsset1 as string;
        if (resolvedAssets[k]) {
          (props as Record<string, unknown>)._resolvedImageUrl1 = resolvedAssets[k];
          const id = spec.assets[k];
          if (allowRemoteDemoImages && typeof id === 'string' && id.startsWith('demo-')) usedDemoIds.add(id);
        }
      }
      if (typeof (props as Record<string, unknown>).fallbackAsset1 === 'string') {
        const k = (props as Record<string, unknown>).fallbackAsset1 as string;
        if (resolvedAssets[k]) (props as Record<string, unknown>)._fallbackImageUrl1 = resolvedAssets[k];
      }
      if (typeof (props as Record<string, unknown>).imageAsset2 === 'string') {
        const k = (props as Record<string, unknown>).imageAsset2 as string;
        if (resolvedAssets[k]) {
          (props as Record<string, unknown>)._resolvedImageUrl2 = resolvedAssets[k];
          const id = spec.assets[k];
          if (allowRemoteDemoImages && typeof id === 'string' && id.startsWith('demo-')) usedDemoIds.add(id);
        }
      }
      if (typeof (props as Record<string, unknown>).fallbackAsset2 === 'string') {
        const k = (props as Record<string, unknown>).fallbackAsset2 as string;
        if (resolvedAssets[k]) (props as Record<string, unknown>)._fallbackImageUrl2 = resolvedAssets[k];
      }

      // Inject alt text from enhancement overrides
      const altTexts = overrides?.meta?.imageAltTexts;
      if (altTexts) {
        // HeroSplit: imageAsset → _altText
        if (typeof props.imageAsset === 'string' && altTexts[props.imageAsset as string]) {
          props._altText = altTexts[props.imageAsset as string];
        }
        // ImagePair: imageAsset1 → _altText1, imageAsset2 → _altText2
        const p = props as Record<string, unknown>;
        if (typeof p.imageAsset1 === 'string' && altTexts[p.imageAsset1 as string]) {
          p._altText1 = altTexts[p.imageAsset1 as string];
        }
        if (typeof p.imageAsset2 === 'string' && altTexts[p.imageAsset2 as string]) {
          p._altText2 = altTexts[p.imageAsset2 as string];
        }
      }

      // Inject AI-generated image search terms as fallback alt texts
      const imgTerms = overrides?.imageSearchTerms;
      if (imgTerms) {
        const p = props as Record<string, unknown>;
        if (entry.type === 'HeroSplit' && imgTerms.hero && !props._altText) {
          props._altText = imgTerms.hero;
        }
        if (entry.type === 'ImagePair') {
          if (imgTerms.image1 && !p._altText1) p._altText1 = imgTerms.image1;
          if (imgTerms.image2 && !p._altText2) p._altText2 = imgTerms.image2;
        }
      }

      // Inject form HTML into FinalCTA sections
      if (entry.type === 'FinalCTA') {
        props._formHtml = formHtml;
      }

      return renderer(props);
    })
    .join('\n');

  // 5b. Build attribution footer from demo assets
  const attributions = getDemoAttributions(Array.from(usedDemoIds));
  const attrHtml = renderAttributionFooter(attributions);

  // 6. Wrap in full HTML document
  const html = buildDocument(spec, tokensCss, themeCss, sectionsHtml, attrHtml, overrides?.meta);

  return { html, templateId };
}

function getFallbackForAssetKey(key: string, assets: Record<string, string>): string | undefined {
  if (key.startsWith('fallback')) return undefined;

  const cap = key.length > 0 ? key[0].toUpperCase() + key.slice(1) : key;
  const candidates = [`fallback${cap}`, `fallback-${key}`];
  for (const c of candidates) {
    if (c in assets && typeof assets[c] === 'string') return assets[c];
  }
  return undefined;
}

// ── Document wrapper ───────────────────────────────────────────────────────────

function buildDocument(
  spec: TemplateSpec,
  tokensCss: string,
  themeCss: string,
  sectionsHtml: string,
  attributionHtml: string,
  meta?: V1MetaOverrides
): string {
  const pageTitle = meta?.pageTitle || spec.metadata.name;
  const metaDesc = meta?.metaDescription || spec.metadata.description;
  const taglineTag = meta?.tagline
    ? `\n  <meta name="v1-tagline" content="${escapeAttr(meta.tagline)}">`
    : '';

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="${escapeAttr(metaDesc)}">${taglineTag}
  <title>${escapeHtml(pageTitle)}</title>
  <style>
/* === v1 tokens === */
${tokensCss}
/* === v1 theme: ${spec.theme} === */
${themeCss}
  </style>
</head>
<body>
  <div class="v1-page">
${sectionsHtml}
${attributionHtml}
  </div>
</body>
</html>`;
}

// ── Attribution footer ──────────────────────────────────────────────────────

function renderAttributionFooter(attributions: DemoAssetEntry[]): string {
  if (attributions.length === 0) return '';

  const credits = attributions
    .map(
      (a) =>
        `<a href="${escapeAttr(a.source_page_url)}" target="_blank" rel="noopener noreferrer" style="color: inherit; text-decoration: underline;">${escapeHtml(a.attribution_text)}</a>`
    )
    .join(' · ');

  return `
<footer class="v1-attribution" style="
  padding: 12px 24px;
  background: #f5f5f5;
  color: #666;
  font-size: 11px;
  text-align: center;
  border-top: 1px solid #e0e0e0;
">
  Demo images: ${credits}
</footer>`;
}

// ── Helpers ────────────────────────────────────────────────────────────────────

function escapeHtml(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

function escapeAttr(str: string): string {
  return str.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

